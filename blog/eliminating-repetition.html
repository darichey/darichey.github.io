<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Eliminating repetition</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/2b7e1eaf112ab29c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2b7e1eaf112ab29c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-ff44f97138765e5a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fd739288d0079ea1.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-c314b761d5a80267.js" defer=""></script><script src="/_next/static/8wq5O26GOmTOakrhUM5Lw/_buildManifest.js" defer=""></script><script src="/_next/static/8wq5O26GOmTOakrhUM5Lw/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex justify-center my-10"><div class="flex flex-col w-4/5 md:w-1/3 gap-4"><section class="flex flex-row justify-around"><a class="font-semibold text-2xl" href="/">Home</a><a class="font-semibold text-2xl" href="/blog">Blog</a></section><div class="text-center border-y-2 py-5"><h1 class="text-4xl font-bold text-sky-600">Eliminating repetition</h1><h2>over-engineering a homework assignment for fun</h2><h3>2022-01-28</h3></div><div class="post flex flex-col gap-4 text-xl leading-relaxed content"><p>For a class assignment, I had to write a tiny interpreter for a toy language whose specification was given to us. This
post explores the process of recognizing and eliminating some repetition in the interpreter.</p>
<h2>Basic factoring</h2>
<p>The language has basic arithmetic operations like plus, minus, and times which are modeled in the obvious way. An
initial attempt at the function for evaluating arithmetic expressions might look something like the
following.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> eval_arith (s : store) (a: iarith) -&gt; <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">match</span> a <span class="hljs-keyword">with</span>
  ...
  | <span class="hljs-type">Plus</span> (x, y) -&gt; eval_arith s x + eval_arith s y
  | <span class="hljs-type">Minus</span> (x, y) -&gt; eval_arith s x - eval_arith s y
  | <span class="hljs-type">Times</span> (x, y) -&gt; eval_arith s x * eval_arith s y
</code></pre>
<p>Note that the <code>store</code> argument maps variable names to integer values. This is the &quot;environment&quot; that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn&#x27;t immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.</p>
<p>Honestly, this code is perfectly fine as-is, but I just can&#x27;t help myself when I see a pattern like that... We can
factor out the repetition by writing something like:</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> foo f g a b = f (g a) (g b)

<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> eval_arith (s : store) (a: iarith) -&gt; <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">match</span> a <span class="hljs-keyword">with</span>
  ...
  | <span class="hljs-type">Plus</span> (x, y) -&gt; foo ( + ) (eval_arith s) x y
  | <span class="hljs-type">Minus</span> (x, y) -&gt; foo ( - ) (eval_arith s) x y
  | <span class="hljs-type">Times</span> (x, y) -&gt; foo ( * ) (eval_arith s) x y
</code></pre>
<p><code>foo</code> is a function that applies a function to <code>a</code> and <code>b</code> and then combines the results of those functions using a
given binary operator. It has the type <code>(&#x27;a -&gt; &#x27;a -&gt; &#x27;b) -&gt; (&#x27;c -&gt; &#x27;a) -&gt; &#x27;c -&gt; &#x27;c -&gt; &#x27;b</code>. A quick
<a href="https://hoogle.haskell.org/?hoogle=(a%20-%3E%20a%20-%3E%20b)%20-%3E%20(c%20-%3E%20a)%20-%3E%20c%20-%3E%20c%20-%3E%20b">hoogle search</a>
shows that Haskell has such a function called <code>on</code> in <code>base</code>, so let&#x27;s call it that.</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> on f g a b = f (g a) (g b)

<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> eval_arith (s : store) (a: iarith) -&gt; <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">match</span> a <span class="hljs-keyword">with</span>
  ...
  | <span class="hljs-type">Plus</span> (x, y) -&gt; on ( + ) (eval_arith s) x y
  | <span class="hljs-type">Minus</span> (x, y) -&gt; on ( - ) (eval_arith s) x y
  | <span class="hljs-type">Times</span> (x, y) -&gt; on ( * ) (eval_arith s) x y
</code></pre>
<h2>The Reader Monad</h2>
<p>At this point, I&#x27;m fairly satisfied with this aspect of the implementation, but I want to revisit another aspect that I
mentioned earlier:</p>
<blockquote>
<p>Note that the <code>store</code> argument maps variable names to integer values. This is the &quot;environment&quot; that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn&#x27;t immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.</p>
</blockquote>
<p>Classically, we use the <code>Reader</code> monad to do this environment passing implicitly. I&#x27;ve only been playing with OCaml
for a week or so, but my understanding is that this kind of functional programming is not quite so popular in OCaml (the standard library does not have <code>Reader</code> and I couldn&#x27;t find a de facto standard implementation like in Haskell&#x27;s <code>mtl</code>).
Given that, I decided to quickly re-implement the language in Haskell where I can make use of <code>mtl</code>, <code>do</code> notation,
etc..</p>
<p>Using <code>Reader</code> to pass around the environment, we can write <code>evalArith</code> as follows:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">evalArith</span> :: <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
...
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Plus</span> x y) = <span class="hljs-keyword">do</span>
  xn &lt;- evalArith x
  yn &lt;- evalArith y
  return $ xn + yn
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Minus</span> x y) = <span class="hljs-keyword">do</span>
  xn &lt;- evalArith x
  yn &lt;- evalArith y
  return $ xn - yn
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Times</span> x y) = <span class="hljs-keyword">do</span>
  xn &lt;- evalArith x
  yn &lt;- evalArith y
  return $ xn * yn
</code></pre>
<p>Success! The environment no longer needs to be explicitly passed down to the sub-computations. Again, there&#x27;s a
not-insignificant amount of repetition here. Let&#x27;s factor it out:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">foo&#x27;</span> f g x y = <span class="hljs-keyword">do</span>
  xn &lt;- g x
  yn &lt;- g y
  return $ f xn yn

<span class="hljs-title">evalArith</span> :: <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
...
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Plus</span> x y) = foo (+) evalArith x y
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Minus</span> x y) = foo (-) evalArith x y
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Times</span> x y) = foo (*) evalArith x y
</code></pre>
<p>I&#x27;m not exactly sure what to call this function yet, but let&#x27;s move on for now.</p>
<h2>Combining them</h2>
<p>I&#x27;m still not quite satisfied with this implementation. In the first section, we discovered a function, <code>on</code>, that
encapsulates the idea of combining the results of applying a function to two different arguments. Now, we&#x27;re still doing
that, but we&#x27;re not using <code>on</code>! Let&#x27;s see how we can define <code>foo</code> in terms of <code>on</code> to get the best of both worlds.</p>
<p>To start, let&#x27;s lay out the types of each function and try to solve the type puzzle (we&#x27;ll need to figure out how to
fit together the &quot;pieces&quot;).</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">on</span>  :: (b   -&gt; b   -&gt; c  ) -&gt; (a      -&gt; b               ) -&gt; a      -&gt; a      -&gt; c
</code></pre>
<p>Lining up the types like this shows how these have very similar shapes! However, we quickly realize that there&#x27;s no
consistent instantiation of the type variables. We have <code>a ~ IArith</code>, but <code>b</code> needs to be both <code>Int</code> and
<code>Reader Store Int</code> (and similarly for <code>c</code>). This tells us that <code>foo</code> and <code>on</code> aren&#x27;t the same, so we need <em>something</em> to
transform one to the other. To determine what that &quot;something&quot; is, let&#x27;s consider what we have and what we need. We&#x27;ll
use typed holes to guide the process.</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">foo</span> f g x y = on _ _ _ _
</code></pre>
<p>We already know that <code>a ~ IArith</code> is valid, and we have two arguments of that type, <code>x</code> and <code>y</code>, so let&#x27;s plug those in.</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">foo</span> f g x y = on _ _ x y
</code></pre>
<p>Let&#x27;s take a look at what the compiler has to say about the remaining holes.</p>
<pre><code>app/Main.hs:43:18: error:
    • Found hole: _ :: b0 -&gt; b0 -&gt; Reader Store Int
      Where: ‘b0’ is an ambiguous type variable
    ...
   |
43 | foo f g x y = on _ _ x y
   |                  ^

app/Main.hs:43:20: error:
    • Found hole: _ :: IArith -&gt; b0
      Where: ‘b0’ is an ambiguous type variable
    ...
   |
43 | foo f g x y = on _ _ x y
   |                    ^
</code></pre>
<p>We can see that we have a free type variable, <code>b0</code>. We can also see that the second hole has a shape similar to
something we have: <code>g :: IArith -&gt; Reader Store Int</code>. Let&#x27;s plug in <code>g</code> for the second hole (therefore setting
<code>b0 ~ Reader Store Int</code>) and see what that does for us.</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">foo</span> f g x y = on _ g x y
</code></pre>
<pre><code>app/Main.hs:43:18: error:
    • Found hole:
        _ :: Reader Store Int -&gt; Reader Store Int -&gt; Reader Store Int
    ...
   |
43 | foo f g x y = on _ g x y
   |                  ^
</code></pre>
<p>If you squint, the type of <code>f</code> and the type of the hole look kind of similar...</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">_</span> :: <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">f</span> ::              <span class="hljs-type">Int</span> -&gt;              <span class="hljs-type">Int</span> -&gt;              <span class="hljs-type">Int</span>
</code></pre>
<p>We have a pure function on <code>Int</code>s and we want a similar function on <code>Ints</code> where each argument and the result <em>also</em>
have an associated environment. In Haskell terms, we want to &quot;lift&quot; the function we have into the Reader monad. This situation turns out to be incredibly common when dealing with monads. For functions of two arguments, Haskell has a function, <code>liftM2</code>, that will do precisely what we want.</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">liftM2</span> :: <span class="hljs-type">Monad</span> m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r
</code></pre>
<p>Therefore, we can write <code>foo</code> as follows:</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">foo</span> :: (<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
<span class="hljs-title">foo</span> f g x y = on (liftM2 f) g x y
</code></pre>
<p>I&#x27;m not sure if there&#x27;s some kind of naming convention for functions like these, but I went with <code>onLiftM2</code> because...
it&#x27;s <code>on</code>... after <code>liftM2</code>. Eta-reducing and generalizing the type signature (which will allow the same function to be used for boolean evaluation!), we arrive at the final definition of both <code>onLiftM2</code> and <code>evalArith</code>.</p>
<pre><code class="hljs language-haskell"><span class="hljs-title">onLiftM2</span> :: <span class="hljs-type">Monad</span> m =&gt; (a -&gt; a -&gt; c) -&gt; (b -&gt; m a) -&gt; b -&gt; b -&gt; m c
<span class="hljs-title">onLiftM2</span> = on . liftM2

<span class="hljs-title">evalArith</span> :: <span class="hljs-type">IArith</span> -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Store</span> <span class="hljs-type">Int</span>
...
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Plus</span> x y)  = onLiftM2 (+) evalArith x y
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Minus</span> x y) = onLiftM2 (-) evalArith x y
<span class="hljs-title">evalArith</span> (<span class="hljs-type">Times</span> x y) = onLiftM2 (*) evalArith x y
</code></pre>
<h2>Conclusion</h2>
<p>And that&#x27;s it! We started with some repetitive code and used the power of type-driven development and monads to...
increase the size of the code (measured in number of characters) by about 40%! One might look at that result ask why we bothered doing all of this. While eliminating repetition <em>can</em> (and often does, at larger scales) decrease code size, that&#x27;s not its primary goal.</p>
<p>Eliminating repetition serves primarily to decrease cognitive load. At first, one might disagree with that conclusion. It is clearly easier to write repetitive code. After all, the repetitive solution was the first we came up with, and it worked fine. To understand the final version, you have to understand <code>on</code>, <code>liftM2</code>, <code>Reader</code>, and more! Surely that makes the cognitive load associated with the final version higher!</p>
<p>I would disagree. Decreasing cognitive load is something that is becoming increasingly popular in modern programming (largely inspired by functional programming). It manifests itself as things like static typing or Rust&#x27;s borrow checker, neither of which are always <em>easy</em> to work with/around. Even so, by their nature, they limit the number of things programmers have to think about. Similarly, recognizing and abstracting patterns allows readers of code to learn something once and then re-use that knowledge where the abstraction is used.</p>
<p>This specific example <em>is</em> over-engineered, but the same principles apply when working with much larger codebases where the benefits increase exponentially. And, of course, it was really about the friends we made along the way.</p></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Eliminating repetition","subtitle":"over-engineering a homework assignment for fun","date":"2022-01-28","body":{"raw":"\nFor a class assignment, I had to write a tiny interpreter for a toy language whose specification was given to us. This\npost explores the process of recognizing and eliminating some repetition in the interpreter.\n\n## Basic factoring\n\nThe language has basic arithmetic operations like plus, minus, and times which are modeled in the obvious way. An\ninitial attempt at the function for evaluating arithmetic expressions might look something like the\nfollowing.\n\n```ocaml\nlet rec eval_arith (s : store) (a: iarith) -\u003e int =\n  match a with\n  ...\n  | Plus (x, y) -\u003e eval_arith s x + eval_arith s y\n  | Minus (x, y) -\u003e eval_arith s x - eval_arith s y\n  | Times (x, y) -\u003e eval_arith s x * eval_arith s y\n```\n\nNote that the `store` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.\n\nHonestly, this code is perfectly fine as-is, but I just can't help myself when I see a pattern like that... We can\nfactor out the repetition by writing something like:\n\n```ocaml\nlet foo f g a b = f (g a) (g b)\n\nlet rec eval_arith (s : store) (a: iarith) -\u003e int =\n  match a with\n  ...\n  | Plus (x, y) -\u003e foo ( + ) (eval_arith s) x y\n  | Minus (x, y) -\u003e foo ( - ) (eval_arith s) x y\n  | Times (x, y) -\u003e foo ( * ) (eval_arith s) x y\n```\n\n`foo` is a function that applies a function to `a` and `b` and then combines the results of those functions using a\ngiven binary operator. It has the type `('a -\u003e 'a -\u003e 'b) -\u003e ('c -\u003e 'a) -\u003e 'c -\u003e 'c -\u003e 'b`. A quick\n[hoogle search](\u003chttps://hoogle.haskell.org/?hoogle=(a%20-%3E%20a%20-%3E%20b)%20-%3E%20(c%20-%3E%20a)%20-%3E%20c%20-%3E%20c%20-%3E%20b\u003e)\nshows that Haskell has such a function called `on` in `base`, so let's call it that.\n\n```ocaml\nlet on f g a b = f (g a) (g b)\n\nlet rec eval_arith (s : store) (a: iarith) -\u003e int =\n  match a with\n  ...\n  | Plus (x, y) -\u003e on ( + ) (eval_arith s) x y\n  | Minus (x, y) -\u003e on ( - ) (eval_arith s) x y\n  | Times (x, y) -\u003e on ( * ) (eval_arith s) x y\n```\n\n## The Reader Monad\n\nAt this point, I'm fairly satisfied with this aspect of the implementation, but I want to revisit another aspect that I\nmentioned earlier:\n\n\u003e Note that the `store` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.\n\nClassically, we use the `Reader` monad to do this environment passing implicitly. I've only been playing with OCaml\nfor a week or so, but my understanding is that this kind of functional programming is not quite so popular in OCaml (the standard library does not have `Reader` and I couldn't find a de facto standard implementation like in Haskell's `mtl`).\nGiven that, I decided to quickly re-implement the language in Haskell where I can make use of `mtl`, `do` notation,\netc..\n\nUsing `Reader` to pass around the environment, we can write `evalArith` as follows:\n\n```haskell\nevalArith :: IArith -\u003e Reader Store Int\n...\nevalArith (Plus x y) = do\n  xn \u003c- evalArith x\n  yn \u003c- evalArith y\n  return $ xn + yn\nevalArith (Minus x y) = do\n  xn \u003c- evalArith x\n  yn \u003c- evalArith y\n  return $ xn - yn\nevalArith (Times x y) = do\n  xn \u003c- evalArith x\n  yn \u003c- evalArith y\n  return $ xn * yn\n```\n\nSuccess! The environment no longer needs to be explicitly passed down to the sub-computations. Again, there's a\nnot-insignificant amount of repetition here. Let's factor it out:\n\n```haskell\nfoo :: (Int -\u003e Int -\u003e Int) -\u003e (IArith -\u003e Reader Store Int) -\u003e IArith -\u003e IArith -\u003e Reader Store Int\nfoo' f g x y = do\n  xn \u003c- g x\n  yn \u003c- g y\n  return $ f xn yn\n\nevalArith :: IArith -\u003e Reader Store Int\n...\nevalArith (Plus x y) = foo (+) evalArith x y\nevalArith (Minus x y) = foo (-) evalArith x y\nevalArith (Times x y) = foo (*) evalArith x y\n```\n\nI'm not exactly sure what to call this function yet, but let's move on for now.\n\n## Combining them\n\nI'm still not quite satisfied with this implementation. In the first section, we discovered a function, `on`, that\nencapsulates the idea of combining the results of applying a function to two different arguments. Now, we're still doing\nthat, but we're not using `on`! Let's see how we can define `foo` in terms of `on` to get the best of both worlds.\n\nTo start, let's lay out the types of each function and try to solve the type puzzle (we'll need to figure out how to\nfit together the \"pieces\").\n\n```haskell\nfoo :: (Int -\u003e Int -\u003e Int) -\u003e (IArith -\u003e Reader Store Int) -\u003e IArith -\u003e IArith -\u003e Reader Store Int\non  :: (b   -\u003e b   -\u003e c  ) -\u003e (a      -\u003e b               ) -\u003e a      -\u003e a      -\u003e c\n```\n\nLining up the types like this shows how these have very similar shapes! However, we quickly realize that there's no\nconsistent instantiation of the type variables. We have `a ~ IArith`, but `b` needs to be both `Int` and\n`Reader Store Int` (and similarly for `c`). This tells us that `foo` and `on` aren't the same, so we need _something_ to\ntransform one to the other. To determine what that \"something\" is, let's consider what we have and what we need. We'll\nuse typed holes to guide the process.\n\n```haskell\nfoo :: (Int -\u003e Int -\u003e Int) -\u003e (IArith -\u003e Reader Store Int) -\u003e IArith -\u003e IArith -\u003e Reader Store Int\nfoo f g x y = on _ _ _ _\n```\n\nWe already know that `a ~ IArith` is valid, and we have two arguments of that type, `x` and `y`, so let's plug those in.\n\n```haskell\nfoo :: (Int -\u003e Int -\u003e Int) -\u003e (IArith -\u003e Reader Store Int) -\u003e IArith -\u003e IArith -\u003e Reader Store Int\nfoo f g x y = on _ _ x y\n```\n\nLet's take a look at what the compiler has to say about the remaining holes.\n\n```\napp/Main.hs:43:18: error:\n    • Found hole: _ :: b0 -\u003e b0 -\u003e Reader Store Int\n      Where: ‘b0’ is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                  ^\n\napp/Main.hs:43:20: error:\n    • Found hole: _ :: IArith -\u003e b0\n      Where: ‘b0’ is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                    ^\n```\n\nWe can see that we have a free type variable, `b0`. We can also see that the second hole has a shape similar to\nsomething we have: `g :: IArith -\u003e Reader Store Int`. Let's plug in `g` for the second hole (therefore setting\n`b0 ~ Reader Store Int`) and see what that does for us.\n\n```haskell\nfoo :: (Int -\u003e Int -\u003e Int) -\u003e (IArith -\u003e Reader Store Int) -\u003e IArith -\u003e IArith -\u003e Reader Store Int\nfoo f g x y = on _ g x y\n```\n\n```\napp/Main.hs:43:18: error:\n    • Found hole:\n        _ :: Reader Store Int -\u003e Reader Store Int -\u003e Reader Store Int\n    ...\n   |\n43 | foo f g x y = on _ g x y\n   |                  ^\n```\n\nIf you squint, the type of `f` and the type of the hole look kind of similar...\n\n```haskell\n_ :: Reader Store Int -\u003e Reader Store Int -\u003e Reader Store Int\nf ::              Int -\u003e              Int -\u003e              Int\n```\n\nWe have a pure function on `Int`s and we want a similar function on `Ints` where each argument and the result _also_\nhave an associated environment. In Haskell terms, we want to \"lift\" the function we have into the Reader monad. This situation turns out to be incredibly common when dealing with monads. For functions of two arguments, Haskell has a function, `liftM2`, that will do precisely what we want.\n\n```haskell\nliftM2 :: Monad m =\u003e (a1 -\u003e a2 -\u003e r) -\u003e m a1 -\u003e m a2 -\u003e m r\n```\n\nTherefore, we can write `foo` as follows:\n\n```haskell\nfoo :: (Int -\u003e Int -\u003e Int) -\u003e (IArith -\u003e Reader Store Int) -\u003e IArith -\u003e IArith -\u003e Reader Store Int\nfoo f g x y = on (liftM2 f) g x y\n```\n\nI'm not sure if there's some kind of naming convention for functions like these, but I went with `onLiftM2` because...\nit's `on`... after `liftM2`. Eta-reducing and generalizing the type signature (which will allow the same function to be used for boolean evaluation!), we arrive at the final definition of both `onLiftM2` and `evalArith`.\n\n```haskell\nonLiftM2 :: Monad m =\u003e (a -\u003e a -\u003e c) -\u003e (b -\u003e m a) -\u003e b -\u003e b -\u003e m c\nonLiftM2 = on . liftM2\n\nevalArith :: IArith -\u003e Reader Store Int\n...\nevalArith (Plus x y)  = onLiftM2 (+) evalArith x y\nevalArith (Minus x y) = onLiftM2 (-) evalArith x y\nevalArith (Times x y) = onLiftM2 (*) evalArith x y\n```\n\n## Conclusion\n\nAnd that's it! We started with some repetitive code and used the power of type-driven development and monads to...\nincrease the size of the code (measured in number of characters) by about 40%! One might look at that result ask why we bothered doing all of this. While eliminating repetition _can_ (and often does, at larger scales) decrease code size, that's not its primary goal.\n\nEliminating repetition serves primarily to decrease cognitive load. At first, one might disagree with that conclusion. It is clearly easier to write repetitive code. After all, the repetitive solution was the first we came up with, and it worked fine. To understand the final version, you have to understand `on`, `liftM2`, `Reader`, and more! Surely that makes the cognitive load associated with the final version higher!\n\nI would disagree. Decreasing cognitive load is something that is becoming increasingly popular in modern programming (largely inspired by functional programming). It manifests itself as things like static typing or Rust's borrow checker, neither of which are always _easy_ to work with/around. Even so, by their nature, they limit the number of things programmers have to think about. Similarly, recognizing and abstracting patterns allows readers of code to learn something once and then re-use that knowledge where the abstraction is used.\n\nThis specific example _is_ over-engineered, but the same principles apply when working with much larger codebases where the benefits increase exponentially. And, of course, it was really about the friends we made along the way.\n","code":"var Component=(()=\u003e{var d=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var u=(s,e)=\u003e()=\u003e(e||s((e={exports:{}}).exports,e),e.exports),N=(s,e)=\u003e{for(var a in e)t(s,a,{get:e[a],enumerable:!0})},h=(s,e,a,i)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!j.call(s,l)\u0026\u0026l!==a\u0026\u0026t(s,l,{get:()=\u003ee[l],enumerable:!(i=p(e,l))||i.enumerable});return s};var f=(s,e,a)=\u003e(a=s!=null?d(y(s)):{},h(e||!s||!s.__esModule?t(a,\"default\",{value:s,enumerable:!0}):a,s)),g=s=\u003eh(t({},\"__esModule\",{value:!0}),s);var c=u((k,r)=\u003e{r.exports=_jsx_runtime});var b={};N(b,{default:()=\u003eI,frontmatter:()=\u003ew});var n=f(c()),w={title:\"Eliminating repetition\",subtitle:\"over-engineering a homework assignment for fun\",date:\"2022-01-28\"};function o(s){let e=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",span:\"span\",a:\"a\",blockquote:\"blockquote\",em:\"em\"},s.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:`For a class assignment, I had to write a tiny interpreter for a toy language whose specification was given to us. This\npost explores the process of recognizing and eliminating some repetition in the interpreter.`}),`\n`,(0,n.jsx)(e.h2,{children:\"Basic factoring\"}),`\n`,(0,n.jsx)(e.p,{children:`The language has basic arithmetic operations like plus, minus, and times which are modeled in the obvious way. An\ninitial attempt at the function for evaluating arithmetic expressions might look something like the\nfollowing.`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-ocaml\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"rec\"}),\" eval_arith (s : store) (a: iarith) -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"int\"}),` =\n  `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"match\"}),\" a \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"with\"}),`\n  ...\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` (x, y) -\u003e eval_arith s x + eval_arith s y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` (x, y) -\u003e eval_arith s x - eval_arith s y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` (x, y) -\u003e eval_arith s x * eval_arith s y\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that the \",(0,n.jsx)(e.code,{children:\"store\"}),` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.`]}),`\n`,(0,n.jsx)(e.p,{children:`Honestly, this code is perfectly fine as-is, but I just can't help myself when I see a pattern like that... We can\nfactor out the repetition by writing something like:`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-ocaml\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),` foo f g a b = f (g a) (g b)\n\n`,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"rec\"}),\" eval_arith (s : store) (a: iarith) -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"int\"}),` =\n  `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"match\"}),\" a \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"with\"}),`\n  ...\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` (x, y) -\u003e foo ( + ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` (x, y) -\u003e foo ( - ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` (x, y) -\u003e foo ( * ) (eval_arith s) x y\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"foo\"}),\" is a function that applies a function to \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),` and then combines the results of those functions using a\ngiven binary operator. It has the type `,(0,n.jsx)(e.code,{children:\"('a -\u003e 'a -\u003e 'b) -\u003e ('c -\u003e 'a) -\u003e 'c -\u003e 'c -\u003e 'b\"}),`. A quick\n`,(0,n.jsx)(e.a,{href:\"https://hoogle.haskell.org/?hoogle=(a%20-%3E%20a%20-%3E%20b)%20-%3E%20(c%20-%3E%20a)%20-%3E%20c%20-%3E%20c%20-%3E%20b\",children:\"hoogle search\"}),`\nshows that Haskell has such a function called `,(0,n.jsx)(e.code,{children:\"on\"}),\" in \",(0,n.jsx)(e.code,{children:\"base\"}),\", so let's call it that.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-ocaml\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),` on f g a b = f (g a) (g b)\n\n`,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"rec\"}),\" eval_arith (s : store) (a: iarith) -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"int\"}),` =\n  `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"match\"}),\" a \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"with\"}),`\n  ...\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` (x, y) -\u003e on ( + ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` (x, y) -\u003e on ( - ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` (x, y) -\u003e on ( * ) (eval_arith s) x y\n`]})}),`\n`,(0,n.jsx)(e.h2,{children:\"The Reader Monad\"}),`\n`,(0,n.jsx)(e.p,{children:`At this point, I'm fairly satisfied with this aspect of the implementation, but I want to revisit another aspect that I\nmentioned earlier:`}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Note that the \",(0,n.jsx)(e.code,{children:\"store\"}),` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Classically, we use the \",(0,n.jsx)(e.code,{children:\"Reader\"}),` monad to do this environment passing implicitly. I've only been playing with OCaml\nfor a week or so, but my understanding is that this kind of functional programming is not quite so popular in OCaml (the standard library does not have `,(0,n.jsx)(e.code,{children:\"Reader\"}),\" and I couldn't find a de facto standard implementation like in Haskell's \",(0,n.jsx)(e.code,{children:\"mtl\"}),`).\nGiven that, I decided to quickly re-implement the language in Haskell where I can make use of `,(0,n.jsx)(e.code,{children:\"mtl\"}),\", \",(0,n.jsx)(e.code,{children:\"do\"}),` notation,\netc..`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"Reader\"}),\" to pass around the environment, we can write \",(0,n.jsx)(e.code,{children:\"evalArith\"}),\" as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n...\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),\" x y) = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn \u003c- evalArith x\n  yn \u003c- evalArith y\n  return $ xn + yn\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),\" x y) = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn \u003c- evalArith x\n  yn \u003c- evalArith y\n  return $ xn - yn\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),\" x y) = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn \u003c- evalArith x\n  yn \u003c- evalArith y\n  return $ xn * yn\n`]})}),`\n`,(0,n.jsx)(e.p,{children:`Success! The environment no longer needs to be explicitly passed down to the sub-computations. Again, there's a\nnot-insignificant amount of repetition here. Let's factor it out:`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo'\"}),\" f g x y = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn \u003c- g x\n  yn \u003c- g y\n  return $ f xn yn\n\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n...\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` x y) = foo (+) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` x y) = foo (-) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` x y) = foo (*) evalArith x y\n`]})}),`\n`,(0,n.jsx)(e.p,{children:\"I'm not exactly sure what to call this function yet, but let's move on for now.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Combining them\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"I'm still not quite satisfied with this implementation. In the first section, we discovered a function, \",(0,n.jsx)(e.code,{children:\"on\"}),`, that\nencapsulates the idea of combining the results of applying a function to two different arguments. Now, we're still doing\nthat, but we're not using `,(0,n.jsx)(e.code,{children:\"on\"}),\"! Let's see how we can define \",(0,n.jsx)(e.code,{children:\"foo\"}),\" in terms of \",(0,n.jsx)(e.code,{children:\"on\"}),\" to get the best of both worlds.\"]}),`\n`,(0,n.jsx)(e.p,{children:`To start, let's lay out the types of each function and try to solve the type puzzle (we'll need to figure out how to\nfit together the \"pieces\").`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"on\"}),`  :: (b   -\u003e b   -\u003e c  ) -\u003e (a      -\u003e b               ) -\u003e a      -\u003e a      -\u003e c\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[`Lining up the types like this shows how these have very similar shapes! However, we quickly realize that there's no\nconsistent instantiation of the type variables. We have `,(0,n.jsx)(e.code,{children:\"a ~ IArith\"}),\", but \",(0,n.jsx)(e.code,{children:\"b\"}),\" needs to be both \",(0,n.jsx)(e.code,{children:\"Int\"}),` and\n`,(0,n.jsx)(e.code,{children:\"Reader Store Int\"}),\" (and similarly for \",(0,n.jsx)(e.code,{children:\"c\"}),\"). This tells us that \",(0,n.jsx)(e.code,{children:\"foo\"}),\" and \",(0,n.jsx)(e.code,{children:\"on\"}),\" aren't the same, so we need \",(0,n.jsx)(e.em,{children:\"something\"}),` to\ntransform one to the other. To determine what that \"something\" is, let's consider what we have and what we need. We'll\nuse typed holes to guide the process.`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on _ _ _ _\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We already know that \",(0,n.jsx)(e.code,{children:\"a ~ IArith\"}),\" is valid, and we have two arguments of that type, \",(0,n.jsx)(e.code,{children:\"x\"}),\" and \",(0,n.jsx)(e.code,{children:\"y\"}),\", so let's plug those in.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on _ _ x y\n`]})}),`\n`,(0,n.jsx)(e.p,{children:\"Let's take a look at what the compiler has to say about the remaining holes.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`app/Main.hs:43:18: error:\n    \\u2022 Found hole: _ :: b0 -\u003e b0 -\u003e Reader Store Int\n      Where: \\u2018b0\\u2019 is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                  ^\n\napp/Main.hs:43:20: error:\n    \\u2022 Found hole: _ :: IArith -\u003e b0\n      Where: \\u2018b0\\u2019 is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                    ^\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can see that we have a free type variable, \",(0,n.jsx)(e.code,{children:\"b0\"}),`. We can also see that the second hole has a shape similar to\nsomething we have: `,(0,n.jsx)(e.code,{children:\"g :: IArith -\u003e Reader Store Int\"}),\". Let's plug in \",(0,n.jsx)(e.code,{children:\"g\"}),` for the second hole (therefore setting\n`,(0,n.jsx)(e.code,{children:\"b0 ~ Reader Store Int\"}),\") and see what that does for us.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on _ g x y\n`]})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`app/Main.hs:43:18: error:\n    \\u2022 Found hole:\n        _ :: Reader Store Int -\u003e Reader Store Int -\u003e Reader Store Int\n    ...\n   |\n43 | foo f g x y = on _ g x y\n   |                  ^\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you squint, the type of \",(0,n.jsx)(e.code,{children:\"f\"}),\" and the type of the hole look kind of similar...\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"_\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"f\"}),\" ::              \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e              \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e              \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We have a pure function on \",(0,n.jsx)(e.code,{children:\"Int\"}),\"s and we want a similar function on \",(0,n.jsx)(e.code,{children:\"Ints\"}),\" where each argument and the result \",(0,n.jsx)(e.em,{children:\"also\"}),`\nhave an associated environment. In Haskell terms, we want to \"lift\" the function we have into the Reader monad. This situation turns out to be incredibly common when dealing with monads. For functions of two arguments, Haskell has a function, `,(0,n.jsx)(e.code,{children:\"liftM2\"}),\", that will do precisely what we want.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"liftM2\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Monad\"}),` m =\u003e (a1 -\u003e a2 -\u003e r) -\u003e m a1 -\u003e m a2 -\u003e m r\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Therefore, we can write \",(0,n.jsx)(e.code,{children:\"foo\"}),\" as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on (liftM2 f) g x y\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"I'm not sure if there's some kind of naming convention for functions like these, but I went with \",(0,n.jsx)(e.code,{children:\"onLiftM2\"}),` because...\nit's `,(0,n.jsx)(e.code,{children:\"on\"}),\"... after \",(0,n.jsx)(e.code,{children:\"liftM2\"}),\". Eta-reducing and generalizing the type signature (which will allow the same function to be used for boolean evaluation!), we arrive at the final definition of both \",(0,n.jsx)(e.code,{children:\"onLiftM2\"}),\" and \",(0,n.jsx)(e.code,{children:\"evalArith\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"onLiftM2\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Monad\"}),` m =\u003e (a -\u003e a -\u003e c) -\u003e (b -\u003e m a) -\u003e b -\u003e b -\u003e m c\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"onLiftM2\"}),` = on . liftM2\n\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -\u003e \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n...\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` x y)  = onLiftM2 (+) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` x y) = onLiftM2 (-) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` x y) = onLiftM2 (*) evalArith x y\n`]})}),`\n`,(0,n.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,n.jsxs)(e.p,{children:[`And that's it! We started with some repetitive code and used the power of type-driven development and monads to...\nincrease the size of the code (measured in number of characters) by about 40%! One might look at that result ask why we bothered doing all of this. While eliminating repetition `,(0,n.jsx)(e.em,{children:\"can\"}),\" (and often does, at larger scales) decrease code size, that's not its primary goal.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Eliminating repetition serves primarily to decrease cognitive load. At first, one might disagree with that conclusion. It is clearly easier to write repetitive code. After all, the repetitive solution was the first we came up with, and it worked fine. To understand the final version, you have to understand \",(0,n.jsx)(e.code,{children:\"on\"}),\", \",(0,n.jsx)(e.code,{children:\"liftM2\"}),\", \",(0,n.jsx)(e.code,{children:\"Reader\"}),\", and more! Surely that makes the cognitive load associated with the final version higher!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"I would disagree. Decreasing cognitive load is something that is becoming increasingly popular in modern programming (largely inspired by functional programming). It manifests itself as things like static typing or Rust's borrow checker, neither of which are always \",(0,n.jsx)(e.em,{children:\"easy\"}),\" to work with/around. Even so, by their nature, they limit the number of things programmers have to think about. Similarly, recognizing and abstracting patterns allows readers of code to learn something once and then re-use that knowledge where the abstraction is used.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This specific example \",(0,n.jsx)(e.em,{children:\"is\"}),\" over-engineered, but the same principles apply when working with much larger codebases where the benefits increase exponentially. And, of course, it was really about the friends we made along the way.\"]})]})}function v(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,Object.assign({},s,{children:(0,n.jsx)(o,s)})):o(s)}var I=v;return g(b);})();\n;return Component;"},"_id":"eliminating-repetition.mdx","_raw":{"sourceFilePath":"eliminating-repetition.mdx","sourceFileName":"eliminating-repetition.mdx","sourceFileDir":".","contentType":"mdx","flattenedPath":"eliminating-repetition"},"type":"Post","slug":"eliminating-repetition"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"eliminating-repetition"},"buildId":"8wq5O26GOmTOakrhUM5Lw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>