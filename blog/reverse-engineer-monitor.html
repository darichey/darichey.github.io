<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/img/posts/reverse-engineering-monitor/osd_kvm.webp"/><link rel="preload" as="image" href="/img/posts/reverse-engineering-monitor/osd_input.webp"/><link rel="preload" as="image" href="/img/posts/reverse-engineering-monitor/gaming_intelligence.webp"/><link rel="preload" as="image" href="/img/posts/reverse-engineering-monitor/descriptor.webp"/><link rel="preload" as="image" href="/img/posts/reverse-engineering-monitor/switch_input.webp"/><link rel="stylesheet" href="/_next/static/css/98047ec2b1581ee2.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-6b7d6ff541f85115.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-b78abccdcf7e09a8.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-57e9749fe7baaed3.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-f8ca5b8a7f9bb458.js" async="" crossorigin=""></script><script src="/_next/static/chunks/749-05a220cf126b6365.js" async=""></script><script src="/_next/static/chunks/250-3916ebeef6be7f7c.js" async=""></script><script src="/_next/static/chunks/app/blog/page-100ea955089d01c6.js" async=""></script><script src="/_next/static/chunks/app/page-47317627f9ea58f6.js" async=""></script><title>Reverse engineering my monitor&#x27;s KVM</title><meta name="description" content="Getting my new KVM to work on MacOS and Linux"/><meta name="author" content="David Richey"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="dark:bg-zinc-900"><div class="flex flex-col max-w-[80ch] gap-12 justify-center mt-5 mb-5 p-[2ch] mx-auto"><section class="flex flex-row gap-12"><a class="font-semibold text-2xl text-gray-900 dark:text-white" href="/">Home</a><a class="font-semibold text-2xl text-gray-900 dark:text-white" href="/blog">Blog</a><div class="ml-auto"><section class="flex gap-x-5"><a href="https://github.com/darichey"><img alt="Github Icon" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/img/github_mark.svg"/></a><a href="https://www.linkedin.com/in/darichey/"><img alt="LinkedIn Icon" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/img/linkedin_mark.svg"/></a><a href="https://www.threads.net/@davidrichey1"><img alt="Threads Icon" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/img/threads_mark.svg"/></a><a href="mailto:darichey1@gmail.com"><img alt="Mail Icon" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/img/mail.svg"/></a></section></div></section><div class="prose dark:prose-invert lg:prose-xl max-w-none"><h1><div class="mb-4">Reverse engineering my monitor&#x27;s KVM</div><p class="not-prose text-xl font-normal">Getting my new KVM to work on MacOS and Linux</p><p class="not-prose text-lg font-normal text-slate-400">2024-10-26</p></h1><p>A couple weeks ago, I decided to upgrade my home office setup, in particular my monitor.
I bought an <a href="https://us.msi.com/Monitor/MAG-323UPF">MSI MAG 323UPF</a>. For years, I&#x27;ve been
searching for a multi-comptuer/KVM setup that works just the way I want it to, and this
monitor has finally given me that... after a bit of effort.</p>
<h2>The setup</h2>
<p>I have a personal desktop and a MacBook for work. The monitor has a built-in KVM switch.
The desktop connects to the monitor via DisplayPort and the USB-B port on the monitor, and the
laptop connects via USB-C (with DisplayPort and Power Delivery). Then there&#x27;s three
remaining USB-A 2.0 ports for peripherals.</p>
<p>Out of the box, this setup already works nearly perfectly. I can permanently set the KVM mode to
&quot;Auto&quot; which will make the USB inputs follow the input source. Then I can switch between my
desktop and laptop using the monitor&#x27;s On Screen Display (OSD) with just a couple of presses of
the joystick on the back of the monitor:</p>
<ol>
<li>Press right to open the Input Source menu</li>
<li>Press up/down to select DP or Type C</li>
<li>Press in to confirm</li>
</ol>
<div class="flex flex-row lg:flex-col gap-4 not-prose "><div class="flex flex-col items-center flex-1"><img src="/img/posts/reverse-engineering-monitor/osd_kvm.webp" class="w-full h-auto rounded-lg"/><p class="mt-2 text-center text-gray-600">The OSD KVM menu</p></div><div class="flex flex-col items-center flex-1"><img src="/img/posts/reverse-engineering-monitor/osd_input.webp" class="w-full h-auto rounded-lg"/><p class="mt-2 text-center text-gray-600">The OSD Input Source menu</p></div></div>
<p>This works great! Except I noticed something...</p>
<h2>The Button‚Ñ¢Ô∏è</h2>
<p>There&#x27;s a mystery button on the left side of the monitor! Pressing it seemingly does nothing. What could it
possibly be for??</p>
<p>Actually, I do know what it&#x27;s for, because I read some reviews of the monitor, but I find it extremely odd that,
as far as I can tell, this button is mentioned no where in MSI&#x27;s own material on the monitor. The manual mentions
it only once, in a broad overview of the monitor, calling it the &quot;Macro Key&quot;.</p>
<p>So what&#x27;s it for? It&#x27;s actually kind of neat! You can customize it to perform an action, picking from a list of
actions of varying utility. Things like changing the display preset, or enabling an crosshair, or
<strong>switcing the input source</strong>. Remember earlier I explained the arduous three-step process for switching the
input. I can replace it with just one button! There&#x27;s just one problem...</p>
<h2>&quot;&quot;&quot;Gaming Intelligence&quot;&quot;&quot;</h2>
<p><img src="/img/posts/reverse-engineering-monitor/gaming_intelligence.webp" alt=""/>
The way you customize what the monitor&#x27;s &quot;Macro Key&quot; does is via MSI&#x27;s &quot;&quot;&quot;Gaming Intelligence&quot;&quot;&quot; app. This app
of course only supports Windows which presents two problems:</p>
<ol>
<li>My Mac doesn&#x27;t run Windows</li>
<li>My desktop doesn&#x27;t run Windows (I use NixOS, btw)</li>
</ol>
<blockquote>
<p>Aside: and it&#x27;s not like I just need the software to customize the button and then it&#x27;ll do that action from now on,
regardless of the computer the monitor is connected to. No, since potential functionality includes things like
&quot;run a program&quot;, there has to be software running on the computer to handle that. If it were <strong>just</strong> a KVM button,
then it could just be in the monitor&#x27;s firmware, but whatever.</p>
</blockquote>
<p>At this point, it would be natural to decide I just can&#x27;t use the button, and resign myself to the admittedly very
easy aformentioned three-step process for switching the input. After all, I bought the monitor knowing that I
wouldn&#x27;t be able to use &quot;&quot;&quot;Gaming Intelligence&quot;&quot;&quot; and knowing that the button relied on that.</p>
<h2>Reverse engineering the button</h2>
<p>So anyways, I decided to figure out how the button works. At the end of the day, the software running on the computer
is just communicating with the monitor over USB. I can write software that does the same thing. I just need to
figure out what they&#x27;re saying to each other. So I booted into my Windows partition, installed
&quot;&quot;&quot;Gaming Intelligence&quot;&quot;&quot;, and fired up <a href="https://wiki.wireshark.org/CaptureSetup/USB">WireShark</a>.</p>
<h4>Which device?</h4>
<p>First, we need to determine which device we&#x27;re talking to. WireShark inserts
<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/usb-descriptors">USB descriptor</a> requests for every
device when capture begins. Looking through the responses, we find our answer: I bet it&#x27;s the device vendored by
&quot;<strong>M</strong>icro <strong>S</strong>tar <strong>I</strong>nternational&quot; whose address is <code>1.7.0</code>.</p>
<p><img src="/img/posts/reverse-engineering-monitor/descriptor.webp" alt=""/></p>
<p>Of course, that address will change, so we&#x27;re only relying on it to filter the USB traffic for the current session. If we were to
reboot, for example, we would need to repeat the exercise to determine the new address.</p>
<p>Also note that the address being <code>1.7.0</code> means we are interested in traffic with any <code>1.7.x</code> address. That&#x27;s because you communicate
with a USB device via different <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/usb-endpoints-and-their-pipes">endpoints</a>
which have different addresses.</p>
<p>We also now have the device&#x27;s Vendor ID (<code>0x1462</code>) and Product ID (<code>0x3fa4</code>) which will be useful later.</p>
<h4>When is the button pressed?</h4>
<p>Now let&#x27;s figure out how to detect when the button is pressed. I filtered down to <code>1.7.x</code> and observed the traffic:</p>
<video loop="" muted="" controls=""><source src="/img/posts/reverse-engineering-monitor/polling.mp4" type="video/mp4"/><p>Your browser does not support the video tag.</p></video>
<p>This shows USB HID packets being sent between my computer and the monitor. It looks like
the software is periodically sending a request and getting a response.</p>
<pre class="not-prose"><code class="hljs language-plaintext">Example Request:
0000   1b 00 a0 e6 8a 26 06 c7 ff ff 00 00 00 00 09 00   .....&amp;..........
0010   00 01 00 07 00 02 01 40 00 00 00 01 35 38 30 30   .......@....5800
0020   31 31 30 0d 00 00 00 00 00 00 00 00 00 00 00 00   110.............
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 00 00 00                  ...........
</code></pre>
<pre class="not-prose"><code class="hljs language-plaintext">Example Response:
0000   1b 00 d0 90 e8 15 06 c7 ff ff 00 00 00 00 09 00   ................
0010   01 01 00 07 00 81 01 40 00 00 00 01 35 62 30 30   .......@....5b00
0020   31 31 30 30 30 30 0d 00 00 00 00 00 00 00 00 00   110000..........
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 00 00 00                  ...........
</code></pre>
<p>The bodies of these messages are mostly opaque to me, but WireShark tells me that the
first 27 bytes are some kind of header, and the body is the remaining 64 bytes. So
really the request was <code>01 35 38 30 30 31 31 30 0d</code> and the response was
<code>01 35 62 30 30 31 31 30 30 30 30 0d</code>. These are the same every time.</p>
<p>I&#x27;ve highlighted the responses with that body in red above. Now let&#x27;s see what happens
if we press the button a couple of times.</p>
<video loop="" muted="" controls=""><source src="/img/posts/reverse-engineering-monitor/pressed.mp4" type="video/mp4"/><p>Your browser does not support the video tag.</p></video>
<p>We get a response with a different body!</p>
<pre class="not-prose"><code class="hljs language-plaintext">0000   1b 00 d0 90 e8 15 06 c7 ff ff 00 00 00 00 09 00   ................
0010   01 01 00 07 00 81 01 40 00 00 00 01 35 62 30 30   .......@....5b00
0020   31 31 30 30 30 31 0d 00 00 00 00 00 00 00 00 00   110001..........
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 00 00 00                  ...........
</code></pre>
<p>Again, the part we&#x27;re interested in is just <code>01 35 62 30 30 31 31 30 30 30 31 0d</code>.
We can compare that with the response when the button is <em>not</em> pressed...</p>
<pre class="not-prose"><code class="hljs language-plaintext">01 35 62 30 30 31 31 30 30 30 30 0d
01 35 62 30 30 31 31 30 30 30 31 0d
</code></pre>
<p>... and see that they differ in only a single bit, in the second-to-last byte (<code>30</code> vs <code>31</code>).
This must encode the button state.</p>
<p>To summarize, it seems like the way the software detects if the button is pressed is by periodically
sending a request asking &quot;was the button pressed?&quot; and the monitor responds, with &quot;yes&quot; or &quot;no&quot; encoded
in the response. We can write a simple Rust program using the <a href="https://crates.io/crates/hidapi">hidapi crate</a> that
mimics this polling behavior and inspects the response to determine if the button was pressed.</p>
<pre class="not-prose"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
  <span class="hljs-keyword">let</span> <span class="hljs-variable">api</span> = hidapi::HidApi::<span class="hljs-title function_ invoke__">new_without_enumerate</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
  <span class="hljs-keyword">let</span> (vid, pid) = (<span class="hljs-number">0x1462</span>, <span class="hljs-number">0x3FA4</span>); <span class="hljs-comment">// from the descriptor!</span>
  <span class="hljs-keyword">let</span> <span class="hljs-variable">device</span> = api.<span class="hljs-title function_ invoke__">open</span>(vid, pid).<span class="hljs-title function_ invoke__">unwrap</span>();

  <span class="hljs-keyword">loop</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span> = [<span class="hljs-number">0u8</span>; <span class="hljs-number">65</span>];
    buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0x01</span>;
    buf[<span class="hljs-number">1</span>] = <span class="hljs-number">0x35</span>;
    buf[<span class="hljs-number">2</span>] = <span class="hljs-number">0x38</span>;
    buf[<span class="hljs-number">3</span>] = <span class="hljs-number">0x30</span>;
    buf[<span class="hljs-number">4</span>] = <span class="hljs-number">0x30</span>;
    buf[<span class="hljs-number">5</span>] = <span class="hljs-number">0x31</span>;
    buf[<span class="hljs-number">6</span>] = <span class="hljs-number">0x31</span>;
    buf[<span class="hljs-number">7</span>] = <span class="hljs-number">0x30</span>;
    buf[<span class="hljs-number">8</span>] = <span class="hljs-number">0x0d</span>;
    
    device.<span class="hljs-title function_ invoke__">write</span>(&amp;buf).<span class="hljs-title function_ invoke__">unwrap</span>();
    device.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buf).<span class="hljs-title function_ invoke__">unwrap</span>();

    <span class="hljs-keyword">if</span> buf[<span class="hljs-number">10</span>] == <span class="hljs-number">0x31</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;BUTTON PRESSED&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;not pressed&quot;</span>);
    }

    std::thread::<span class="hljs-title function_ invoke__">sleep</span>(std::time::Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));
  }
}
</code></pre>
<h4>Switching the input</h4>
<p>Now we need to know how to tell the monitor to switch inputs. To this point, I had set the button action to just
open &quot;&quot;&quot;Gaming Intelligence&quot;&quot;&quot; to simplify testing. It would have been very annoying to have the monitor switch
inputs every time I pressed the button while testing, and it would&#x27;ve resulted in extra USB traffic to figure out.
Well, now we need to figure it out. Setting the button action to &quot;Switch the input to USB-C&quot; and pressing it
results in this USB traffic:</p>
<p><img src="/img/posts/reverse-engineering-monitor/switch_input.webp" alt=""/></p>
<p>As before, we can see the polling before I press the button, the different response when I press it,
and now a new request being sent to the monitor, highlighted in yellow:</p>
<pre class="not-prose"><code class="hljs language-plaintext">0000   1b 00 10 20 d7 23 06 c7 ff ff 00 00 00 00 09 00   ... .#..........
0010   00 01 00 07 00 02 01 40 00 00 00 01 35 62 30 30   .......@....5b00
0020   35 30 30 30 30 33 0d 00 00 00 00 00 00 00 00 00   500003..........
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 00 00 00                  ...........
</code></pre>
<p>I repeated this with the button action set to &quot;Switch the input to DP&quot; and saw that the request body differs slightly:</p>
<pre class="not-prose"><code class="hljs language-plaintext">0000   1b 00 50 f3 01 26 06 c7 ff ff 00 00 00 00 09 00   ..P..&amp;..........
0010   00 01 00 07 00 02 01 40 00 00 00 01 35 62 30 30   .......@....5b00
0020   35 30 30 30 30 32 0d 00 00 00 00 00 00 00 00 00   500002..........
0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 00 00 00                  ...........
</code></pre>
<p>Comparing them...</p>
<pre class="not-prose"><code>01 35 62 30 30 35 30 30 30 30 33 0d
01 35 62 30 30 35 30 30 30 30 32 0d
</code></pre>
<p>... we see that again they differ in only the last byte (<code>33</code> vs <code>32</code>). This must encode which input source to select.
We can adjust our Rust program to send this packet after detecing that the button is pressed:</p>
<pre class="not-prose"><code class="hljs language-diff">  if buf[10] == 0x31 {
    println!(&quot;BUTTON PRESSED&quot;);
<span class="hljs-addition">+  let mut buf = [0u8; 65];</span>
<span class="hljs-addition">+  buf[0] = 0x01;</span>
<span class="hljs-addition">+  buf[1] = 0x35;</span>
<span class="hljs-addition">+  buf[2] = 0x62;</span>
<span class="hljs-addition">+  buf[3] = 0x30;</span>
<span class="hljs-addition">+  buf[4] = 0x30;</span>
<span class="hljs-addition">+  buf[5] = 0x35;</span>
<span class="hljs-addition">+  buf[6] = 0x30;</span>
<span class="hljs-addition">+  buf[7] = 0x30;</span>
<span class="hljs-addition">+  buf[8] = 0x30;</span>
<span class="hljs-addition">+  buf[9] = 0x30;</span>
<span class="hljs-addition">+  buf[10] = 0x33; // or 0x32 for DP</span>
<span class="hljs-addition">+  buf[11] = 0x0d;</span>
<span class="hljs-addition">+  device.write(&amp;buf).unwrap();</span>
  } else {
    println!(&quot;not pressed&quot;);
  }
</code></pre>
<h2>Conclusion</h2>
<p>And... we&#x27;re done! After some extra polish, I ran the program on both my desktop and laptop and it just worked!</p>
<video loop="" muted="" controls=""><source src="/img/posts/reverse-engineering-monitor/done.mp4" type="video/mp4"/><p>Your browser does not support the video tag.</p></video>
<p>The code is published <a href="https://github.com/darichey/msi-kvm-switch">here</a>.</p>
<p>This was super satisfying and a fun little weekend project. I of course left out a lot of details and rabbit holes
that went no where. It took me probably ~10 hours between a couple days to get something that worked. If we say
it took me ~3 seconds with the old input-switching process, and ~1 second with the button, that means I only need to
press it 18,000 times before the time investment starts paying off!! At a rate of a couple presses per day, that&#x27;s
somewhere between 16 and 25 years. But I had fun. üòÑ</p></div><footer class="border-t-[1px] border-t-slate-900 dark:border-t-white p-2"></footer></div><script src="/_next/static/chunks/webpack-6b7d6ff541f85115.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/98047ec2b1581ee2.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[7690,[],\"\"]\n5:I[5613,[],\"\"]\n7:I[1778,[],\"\"]\n8:I[5250,[\"749\",\"static/chunks/749-05a220cf126b6365.js\",\"250\",\"static/chunks/250-3916ebeef6be7f7c.js\",\"404\",\"static/chunks/app/blog/page-100ea955089d01c6.js\"],\"\"]\n9:I[1749,[\"749\",\"static/chunks/749-05a220cf126b6365.js\",\"250\",\"static/chunks/250-3916ebeef6be7f7c.js\",\"931\",\"static/chunks/app/page-47317627f9ea58f6.js\"],\"Image\"]\nb:I[8955,[],\"\"]\n6:[\"slug\",\"reverse-engineer-monitor\",\"d\"]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/98047ec2b1581ee2.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"mEGM3PYl6XsWfW5D07y3e\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/reverse-engineer-monitor\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"reverse-engineer-monitor\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"reverse-engineer-monitor\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"reverse-engineer-monitor\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L4\",[\"$\",\"div\",null,{\"className\":\"prose dark:prose-invert lg:prose-xl max-w-none\",\"children\":[[\"$\",\"h1\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-4\",\"children\":\"Reverse engineering my monitor's KVM\"}],[\"$\",\"p\",null,{\"className\":\"not-prose text-xl font-normal\",\"children\":\"Getting my new KVM to work on MacOS and Linux\"}],[\"$\",\"p\",null,{\"className\":\"not-prose text-lg font-normal text-slate-400\",\"children\":\"2024-10-26\"}]]}],[[\"$\",\"p\",null,{\"children\":[\"A couple weeks ago, I decided to upgrade my home office setup, in particular my monitor.\\nI bought an \",[\"$\",\"a\",null,{\"href\":\"https://us.msi.com/Monitor/MAG-323UPF\",\"children\":\"MSI MAG 323UPF\"}],\". For years, I've been\\nsearching for a multi-comptuer/KVM setup that works just the way I want it to, and this\\nmonitor has finally given me that... after a bit of effort.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The setup\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I have a personal desktop and a MacBook for work. The monitor has a built-in KVM switch.\\nThe desktop connects to the monitor via DisplayPort and the USB-B port on the monitor, and the\\nlaptop connects via USB-C (with DisplayPort and Power Delivery). Then there's three\\nremaining USB-A 2.0 ports for peripherals.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Out of the box, this setup already works nearly perfectly. I can permanently set the KVM mode to\\n\\\"Auto\\\" which will make the USB inputs follow the input source. Then I can switch between my\\ndesktop and laptop using the monitor's On Screen Display (OSD) with just a couple of presses of\\nthe joystick on the back of the monitor:\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Press right to open the Input Source menu\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Press up/down to select DP or Type C\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Press in to confirm\"}],\"\\n\"]}],\"\\n\",[\"$\",\"div\",null,{\"className\":\"flex flex-row lg:flex-col gap-4 not-prose \",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center flex-1\",\"children\":[[\"$\",\"img\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/osd_kvm.webp\",\"className\":\"w-full h-auto rounded-lg\"}],[\"$\",\"p\",null,{\"className\":\"mt-2 text-center text-gray-600\",\"children\":\"The OSD KVM menu\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center flex-1\",\"children\":[[\"$\",\"img\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/osd_input.webp\",\"className\":\"w-full h-auto rounded-lg\"}],[\"$\",\"p\",null,{\"className\":\"mt-2 text-center text-gray-600\",\"children\":\"The OSD Input Source menu\"}]]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This works great! Except I noticed something...\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"The Button‚Ñ¢Ô∏è\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"There's a mystery button on the left side of the monitor! Pressing it seemingly does nothing. What could it\\npossibly be for??\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Actually, I do know what it's for, because I read some reviews of the monitor, but I find it extremely odd that,\\nas far as I can tell, this button is mentioned no where in MSI's own material on the monitor. The manual mentions\\nit only once, in a broad overview of the monitor, calling it the \\\"Macro Key\\\".\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"So what's it for? It's actually kind of neat! You can customize it to perform an action, picking from a list of\\nactions of varying utility. Things like changing the display preset, or enabling an crosshair, or\\n\",[\"$\",\"strong\",null,{\"children\":\"switcing the input source\"}],\". Remember earlier I explained the arduous three-step process for switching the\\ninput. I can replace it with just one button! There's just one problem...\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"\\\"\\\"\\\"Gaming Intelligence\\\"\\\"\\\"\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/gaming_intelligence.webp\",\"alt\":\"\"}],\"\\nThe way you customize what the monitor's \\\"Macro Key\\\" does is via MSI's \\\"\\\"\\\"Gaming Intelligence\\\"\\\"\\\" app. This app\\nof course only supports Windows which presents two problems:\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"My Mac doesn't run Windows\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"My desktop doesn't run Windows (I use NixOS, btw)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Aside: and it's not like I just need the software to customize the button and then it'll do that action from now on,\\nregardless of the computer the monitor is connected to. No, since potential functionality includes things like\\n\\\"run a program\\\", there has to be software running on the computer to handle that. If it were \",[\"$\",\"strong\",null,{\"children\":\"just\"}],\" a KVM button,\\nthen it could just be in the monitor's firmware, but whatever.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"At this point, it would be natural to decide I just can't use the button, and resign myself to the admittedly very\\neasy aformentioned three-step process for switching the input. After all, I bought the monitor knowing that I\\nwouldn't be able to use \\\"\\\"\\\"Gaming Intelligence\\\"\\\"\\\" and knowing that the button relied on that.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Reverse engineering the button\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"So anyways, I decided to figure out how the button works. At the end of the day, the software running on the computer\\nis just communicating with the monitor over USB. I can write software that does the same thing. I just need to\\nfigure out what they're saying to each other. So I booted into my Windows partition, installed\\n\\\"\\\"\\\"Gaming Intelligence\\\"\\\"\\\", and fired up \",[\"$\",\"a\",null,{\"href\":\"https://wiki.wireshark.org/CaptureSetup/USB\",\"children\":\"WireShark\"}],\".\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"Which device?\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"First, we need to determine which device we're talking to. WireShark inserts\\n\",[\"$\",\"a\",null,{\"href\":\"https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/usb-descriptors\",\"children\":\"USB descriptor\"}],\" requests for every\\ndevice when capture begins. Looking through the responses, we find our answer: I bet it's the device vendored by\\n\\\"\",[\"$\",\"strong\",null,{\"children\":\"M\"}],\"icro \",[\"$\",\"strong\",null,{\"children\":\"S\"}],\"tar \",[\"$\",\"strong\",null,{\"children\":\"I\"}],\"nternational\\\" whose address is \",[\"$\",\"code\",null,{\"children\":\"1.7.0\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/descriptor.webp\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Of course, that address will change, so we're only relying on it to filter the USB traffic for the current session. If we were to\\nreboot, for example, we would need to repeat the exercise to determine the new address.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Also note that the address being \",[\"$\",\"code\",null,{\"children\":\"1.7.0\"}],\" means we are interested in traffic with any \",[\"$\",\"code\",null,{\"children\":\"1.7.x\"}],\" address. That's because you communicate\\nwith a USB device via different \",[\"$\",\"a\",null,{\"href\":\"https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/usb-endpoints-and-their-pipes\",\"children\":\"endpoints\"}],\"\\nwhich have different addresses.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We also now have the device's Vendor ID (\",[\"$\",\"code\",null,{\"children\":\"0x1462\"}],\") and Product ID (\",[\"$\",\"code\",null,{\"children\":\"0x3fa4\"}],\") which will be useful later.\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"When is the button pressed?\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Now let's figure out how to detect when the button is pressed. I filtered down to \",[\"$\",\"code\",null,{\"children\":\"1.7.x\"}],\" and observed the traffic:\"]}],\"\\n\",[\"$\",\"video\",null,{\"autoplay\":true,\"loop\":true,\"muted\":true,\"playsinline\":true,\"controls\":true,\"children\":[[\"$\",\"source\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/polling.mp4\",\"type\":\"video/mp4\"}],[\"$\",\"p\",null,{\"children\":\"Your browser does not support the video tag.\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This shows USB HID packets being sent between my computer and the monitor. It looks like\\nthe software is periodically sending a request and getting a response.\"}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-plaintext\",\"children\":\"Example Request:\\n0000   1b 00 a0 e6 8a 26 06 c7 ff ff 00 00 00 00 09 00   .....\u0026..........\\n0010   00 01 00 07 00 02 01 40 00 00 00 01 35 38 30 30   .......@....5800\\n0020   31 31 30 0d 00 00 00 00 00 00 00 00 00 00 00 00   110.............\\n0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0050   00 00 00 00 00 00 00 00 00 00 00                  ...........\\n\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-plaintext\",\"children\":\"Example Response:\\n0000   1b 00 d0 90 e8 15 06 c7 ff ff 00 00 00 00 09 00   ................\\n0010   01 01 00 07 00 81 01 40 00 00 00 01 35 62 30 30   .......@....5b00\\n0020   31 31 30 30 30 30 0d 00 00 00 00 00 00 00 00 00   110000..........\\n0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0050   00 00 00 00 00 00 00 00 00 00 00                  ...........\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The bodies of these messages are mostly opaque to me, but WireShark tells me that the\\nfirst 27 bytes are some kind of header, and the body is the remaining 64 bytes. So\\nreally the request was \",[\"$\",\"code\",null,{\"children\":\"01 35 38 30 30 31 31 30 0d\"}],\" and the response was\\n\",[\"$\",\"code\",null,{\"children\":\"01 35 62 30 30 31 31 30 30 30 30 0d\"}],\". These are the same every time.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I've highlighted the responses with that body in red above. Now let's see what happens\\nif we press the button a couple of times.\"}],\"\\n\",[\"$\",\"video\",null,{\"autoplay\":true,\"loop\":true,\"muted\":true,\"playsinline\":true,\"controls\":true,\"children\":[[\"$\",\"source\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/pressed.mp4\",\"type\":\"video/mp4\"}],[\"$\",\"p\",null,{\"children\":\"Your browser does not support the video tag.\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We get a response with a different body!\"}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-plaintext\",\"children\":\"0000   1b 00 d0 90 e8 15 06 c7 ff ff 00 00 00 00 09 00   ................\\n0010   01 01 00 07 00 81 01 40 00 00 00 01 35 62 30 30   .......@....5b00\\n0020   31 31 30 30 30 31 0d 00 00 00 00 00 00 00 00 00   110001..........\\n0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0050   00 00 00 00 00 00 00 00 00 00 00                  ...........\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Again, the part we're interested in is just \",[\"$\",\"code\",null,{\"children\":\"01 35 62 30 30 31 31 30 30 30 31 0d\"}],\".\\nWe can compare that with the response when the button is \",[\"$\",\"em\",null,{\"children\":\"not\"}],\" pressed...\"]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-plaintext\",\"children\":\"01 35 62 30 30 31 31 30 30 30 30 0d\\n01 35 62 30 30 31 31 30 30 30 31 0d\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"... and see that they differ in only a single bit, in the second-to-last byte (\",[\"$\",\"code\",null,{\"children\":\"30\"}],\" vs \",[\"$\",\"code\",null,{\"children\":\"31\"}],\").\\nThis must encode the button state.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"To summarize, it seems like the way the software detects if the button is pressed is by periodically\\nsending a request asking \\\"was the button pressed?\\\" and the monitor responds, with \\\"yes\\\" or \\\"no\\\" encoded\\nin the response. We can write a simple Rust program using the \",[\"$\",\"a\",null,{\"href\":\"https://crates.io/crates/hidapi\",\"children\":\"hidapi crate\"}],\" that\\nmimics this polling behavior and inspects the response to determine if the button was pressed.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-rust\",\"children\":[[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"fn\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-title function_\",\"children\":\"main\"}],\"() {\\n  \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"let\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"api\"}],\" = hidapi::HidApi::\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"new_without_enumerate\"}],\"().\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"unwrap\"}],\"();\\n  \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"let\"}],\" (vid, pid) = (\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x1462\"}],\", \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x3FA4\"}],\"); \",[\"$\",\"span\",null,{\"className\":\"hljs-comment\",\"children\":\"// from the descriptor!\"}],\"\\n  \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"let\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"device\"}],\" = api.\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"open\"}],\"(vid, pid).\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"unwrap\"}],\"();\\n\\n  \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"loop\"}],\" {\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"let\"}],\" \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"mut \"}],[\"$\",\"span\",null,{\"className\":\"hljs-variable\",\"children\":\"buf\"}],\" = [\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0u8\"}],\"; \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"65\"}],\"];\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x01\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x35\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"2\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x38\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"3\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x30\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"4\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x30\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"5\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x31\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"6\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x31\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"7\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x30\"}],\";\\n    buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"8\"}],\"] = \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x0d\"}],\";\\n    \\n    device.\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"write\"}],\"(\u0026buf).\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"unwrap\"}],\"();\\n    device.\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"read\"}],\"(\u0026\",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"mut\"}],\" buf).\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"unwrap\"}],\"();\\n\\n    \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"if\"}],\" buf[\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"10\"}],\"] == \",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"0x31\"}],\" {\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"println!\"}],\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"BUTTON PRESSED\\\"\"}],\");\\n    } \",[\"$\",\"span\",null,{\"className\":\"hljs-keyword\",\"children\":\"else\"}],\" {\\n        \",[\"$\",\"span\",null,{\"className\":\"hljs-built_in\",\"children\":\"println!\"}],\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-string\",\"children\":\"\\\"not pressed\\\"\"}],\");\\n    }\\n\\n    std::thread::\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"sleep\"}],\"(std::time::Duration::\",[\"$\",\"span\",null,{\"className\":\"hljs-title function_ invoke__\",\"children\":\"from_secs\"}],\"(\",[\"$\",\"span\",null,{\"className\":\"hljs-number\",\"children\":\"1\"}],\"));\\n  }\\n}\\n\"]}]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"Switching the input\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Now we need to know how to tell the monitor to switch inputs. To this point, I had set the button action to just\\nopen \\\"\\\"\\\"Gaming Intelligence\\\"\\\"\\\" to simplify testing. It would have been very annoying to have the monitor switch\\ninputs every time I pressed the button while testing, and it would've resulted in extra USB traffic to figure out.\\nWell, now we need to figure it out. Setting the button action to \\\"Switch the input to USB-C\\\" and pressing it\\nresults in this USB traffic:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/switch_input.webp\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"As before, we can see the polling before I press the button, the different response when I press it,\\nand now a new request being sent to the monitor, highlighted in yellow:\"}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-plaintext\",\"children\":\"0000   1b 00 10 20 d7 23 06 c7 ff ff 00 00 00 00 09 00   ... .#..........\\n0010   00 01 00 07 00 02 01 40 00 00 00 01 35 62 30 30   .......@....5b00\\n0020   35 30 30 30 30 33 0d 00 00 00 00 00 00 00 00 00   500003..........\\n0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0050   00 00 00 00 00 00 00 00 00 00 00                  ...........\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I repeated this with the button action set to \\\"Switch the input to DP\\\" and saw that the request body differs slightly:\"}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-plaintext\",\"children\":\"0000   1b 00 50 f3 01 26 06 c7 ff ff 00 00 00 00 09 00   ..P..\u0026..........\\n0010   00 01 00 07 00 02 01 40 00 00 00 01 35 62 30 30   .......@....5b00\\n0020   35 30 30 30 30 32 0d 00 00 00 00 00 00 00 00 00   500002..........\\n0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\\n0050   00 00 00 00 00 00 00 00 00 00 00                  ...........\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Comparing them...\"}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"children\":\"01 35 62 30 30 35 30 30 30 30 33 0d\\n01 35 62 30 30 35 30 30 30 30 32 0d\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"... we see that again they differ in only the last byte (\",[\"$\",\"code\",null,{\"children\":\"33\"}],\" vs \",[\"$\",\"code\",null,{\"children\":\"32\"}],\"). This must encode which input source to select.\\nWe can adjust our Rust program to send this packet after detecing that the button is pressed:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"not-prose\",\"children\":[\"$\",\"code\",null,{\"className\":\"hljs language-diff\",\"children\":[\"  if buf[10] == 0x31 {\\n    println!(\\\"BUTTON PRESSED\\\");\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  let mut buf = [0u8; 65];\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[0] = 0x01;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[1] = 0x35;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[2] = 0x62;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[3] = 0x30;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[4] = 0x30;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[5] = 0x35;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[6] = 0x30;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[7] = 0x30;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[8] = 0x30;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[9] = 0x30;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[10] = 0x33; // or 0x32 for DP\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  buf[11] = 0x0d;\"}],\"\\n\",[\"$\",\"span\",null,{\"className\":\"hljs-addition\",\"children\":\"+  device.write(\u0026buf).unwrap();\"}],\"\\n  } else {\\n    println!(\\\"not pressed\\\");\\n  }\\n\"]}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Conclusion\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"And... we're done! After some extra polish, I ran the program on both my desktop and laptop and it just worked!\"}],\"\\n\",[\"$\",\"video\",null,{\"autoplay\":true,\"loop\":true,\"muted\":true,\"playsinline\":true,\"controls\":true,\"children\":[[\"$\",\"source\",null,{\"src\":\"/img/posts/reverse-engineering-monitor/done.mp4\",\"type\":\"video/mp4\"}],[\"$\",\"p\",null,{\"children\":\"Your browser does not support the video tag.\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The code is published \",[\"$\",\"a\",null,{\"href\":\"https://github.com/darichey/msi-kvm-switch\",\"children\":\"here\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This was super satisfying and a fun little weekend project. I of course left out a lot of details and rabbit holes\\nthat went no where. It took me probably ~10 hours between a couple days to get something that worked. If we say\\nit took me ~3 seconds with the old input-switching process, and ~1 second with the button, that means I only need to\\npress it 18,000 times before the time investment starts paying off!! At a rate of a couple presses per day, that's\\nsomewhere between 16 and 25 years. But I had fun. üòÑ\"}]]]}],null]]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$6\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"dark:bg-zinc-900\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col max-w-[80ch] gap-12 justify-center mt-5 mb-5 p-[2ch] mx-auto\",\"children\":[[\"$\",\"section\",null,{\"className\":\"flex flex-row gap-12\",\"children\":[[\"$\",\"$L8\",null,{\"href\":\"/\",\"className\":\"font-semibold text-2xl text-gray-900 dark:text-white\",\"children\":\"Home\"}],[\"$\",\"$L8\",null,{\"href\":\"/blog\",\"className\":\"font-semibold text-2xl text-gray-900 dark:text-white\",\"children\":\"Blog\"}],[\"$\",\"div\",null,{\"className\":\"ml-auto\",\"children\":[\"$\",\"section\",null,{\"className\":\"flex gap-x-5\",\"children\":[[\"$\",\"$L8\",null,{\"href\":\"https://github.com/darichey\",\"children\":[\"$\",\"$L9\",null,{\"src\":\"/img/github_mark.svg\",\"alt\":\"Github Icon\",\"height\":32,\"width\":32}]}],[\"$\",\"$L8\",null,{\"href\":\"https://www.linkedin.com/in/darichey/\",\"children\":[\"$\",\"$L9\",null,{\"src\":\"/img/linkedin_mark.svg\",\"alt\":\"LinkedIn Icon\",\"height\":32,\"width\":32}]}],[\"$\",\"$L8\",null,{\"href\":\"https://www.threads.net/@davidrichey1\",\"children\":[\"$\",\"$L9\",null,{\"src\":\"/img/threads_mark.svg\",\"alt\":\"Threads Icon\",\"height\":32,\"width\":32}]}],[\"$\",\"$L8\",null,{\"href\":\"mailto:darichey1@gmail.com\",\"children\":[\"$\",\"$L9\",null,{\"src\":\"/img/mail.svg\",\"alt\":\"Mail Icon\",\"height\":32,\"width\":32}]}]]}]}]]}],[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],[\"$\",\"footer\",null,{\"className\":\"border-t-[1px] border-t-slate-900 dark:border-t-white p-2\"}]]}]}]}],null]],\"initialHead\":[false,\"$La\"],\"globalErrorComponent\":\"$b\"}]]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Reverse engineering my monitor's KVM\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Getting my new KVM to work on MacOS and Linux\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"David Richey\"}]]\n4:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>