{"pageProps":{"post":{"title":"Eliminating repetition","subtitle":"over-engineering a homework assignment for fun","date":"2022-01-28","body":{"raw":"\nFor a class assignment, I had to write a tiny interpreter for a toy language whose specification was given to us. This\npost explores the process of recognizing and eliminating some repetition in the interpreter.\n\n## Basic factoring\n\nThe language has basic arithmetic operations like plus, minus, and times which are modeled in the obvious way. An\ninitial attempt at the function for evaluating arithmetic expressions might look something like the\nfollowing.\n\n```ocaml\nlet rec eval_arith (s : store) (a: iarith) -> int =\n  match a with\n  ...\n  | Plus (x, y) -> eval_arith s x + eval_arith s y\n  | Minus (x, y) -> eval_arith s x - eval_arith s y\n  | Times (x, y) -> eval_arith s x * eval_arith s y\n```\n\nNote that the `store` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.\n\nHonestly, this code is perfectly fine as-is, but I just can't help myself when I see a pattern like that... We can\nfactor out the repetition by writing something like:\n\n```ocaml\nlet foo f g a b = f (g a) (g b)\n\nlet rec eval_arith (s : store) (a: iarith) -> int =\n  match a with\n  ...\n  | Plus (x, y) -> foo ( + ) (eval_arith s) x y\n  | Minus (x, y) -> foo ( - ) (eval_arith s) x y\n  | Times (x, y) -> foo ( * ) (eval_arith s) x y\n```\n\n`foo` is a function that applies a function to `a` and `b` and then combines the results of those functions using a\ngiven binary operator. It has the type `('a -> 'a -> 'b) -> ('c -> 'a) -> 'c -> 'c -> 'b`. A quick\n[hoogle search](<https://hoogle.haskell.org/?hoogle=(a%20-%3E%20a%20-%3E%20b)%20-%3E%20(c%20-%3E%20a)%20-%3E%20c%20-%3E%20c%20-%3E%20b>)\nshows that Haskell has such a function called `on` in `base`, so let's call it that.\n\n```ocaml\nlet on f g a b = f (g a) (g b)\n\nlet rec eval_arith (s : store) (a: iarith) -> int =\n  match a with\n  ...\n  | Plus (x, y) -> on ( + ) (eval_arith s) x y\n  | Minus (x, y) -> on ( - ) (eval_arith s) x y\n  | Times (x, y) -> on ( * ) (eval_arith s) x y\n```\n\n## The Reader Monad\n\nAt this point, I'm fairly satisfied with this aspect of the implementation, but I want to revisit another aspect that I\nmentioned earlier:\n\n> Note that the `store` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.\n\nClassically, we use the `Reader` monad to do this environment passing implicitly. I've only been playing with OCaml\nfor a week or so, but my understanding is that this kind of functional programming is not quite so popular in OCaml (the standard library does not have `Reader` and I couldn't find a de facto standard implementation like in Haskell's `mtl`).\nGiven that, I decided to quickly re-implement the language in Haskell where I can make use of `mtl`, `do` notation,\netc..\n\nUsing `Reader` to pass around the environment, we can write `evalArith` as follows:\n\n```haskell\nevalArith :: IArith -> Reader Store Int\n...\nevalArith (Plus x y) = do\n  xn <- evalArith x\n  yn <- evalArith y\n  return $ xn + yn\nevalArith (Minus x y) = do\n  xn <- evalArith x\n  yn <- evalArith y\n  return $ xn - yn\nevalArith (Times x y) = do\n  xn <- evalArith x\n  yn <- evalArith y\n  return $ xn * yn\n```\n\nSuccess! The environment no longer needs to be explicitly passed down to the sub-computations. Again, there's a\nnot-insignificant amount of repetition here. Let's factor it out:\n\n```haskell\nfoo :: (Int -> Int -> Int) -> (IArith -> Reader Store Int) -> IArith -> IArith -> Reader Store Int\nfoo' f g x y = do\n  xn <- g x\n  yn <- g y\n  return $ f xn yn\n\nevalArith :: IArith -> Reader Store Int\n...\nevalArith (Plus x y) = foo (+) evalArith x y\nevalArith (Minus x y) = foo (-) evalArith x y\nevalArith (Times x y) = foo (*) evalArith x y\n```\n\nI'm not exactly sure what to call this function yet, but let's move on for now.\n\n## Combining them\n\nI'm still not quite satisfied with this implementation. In the first section, we discovered a function, `on`, that\nencapsulates the idea of combining the results of applying a function to two different arguments. Now, we're still doing\nthat, but we're not using `on`! Let's see how we can define `foo` in terms of `on` to get the best of both worlds.\n\nTo start, let's lay out the types of each function and try to solve the type puzzle (we'll need to figure out how to\nfit together the \"pieces\").\n\n```haskell\nfoo :: (Int -> Int -> Int) -> (IArith -> Reader Store Int) -> IArith -> IArith -> Reader Store Int\non  :: (b   -> b   -> c  ) -> (a      -> b               ) -> a      -> a      -> c\n```\n\nLining up the types like this shows how these have very similar shapes! However, we quickly realize that there's no\nconsistent instantiation of the type variables. We have `a ~ IArith`, but `b` needs to be both `Int` and\n`Reader Store Int` (and similarly for `c`). This tells us that `foo` and `on` aren't the same, so we need _something_ to\ntransform one to the other. To determine what that \"something\" is, let's consider what we have and what we need. We'll\nuse typed holes to guide the process.\n\n```haskell\nfoo :: (Int -> Int -> Int) -> (IArith -> Reader Store Int) -> IArith -> IArith -> Reader Store Int\nfoo f g x y = on _ _ _ _\n```\n\nWe already know that `a ~ IArith` is valid, and we have two arguments of that type, `x` and `y`, so let's plug those in.\n\n```haskell\nfoo :: (Int -> Int -> Int) -> (IArith -> Reader Store Int) -> IArith -> IArith -> Reader Store Int\nfoo f g x y = on _ _ x y\n```\n\nLet's take a look at what the compiler has to say about the remaining holes.\n\n```\napp/Main.hs:43:18: error:\n    • Found hole: _ :: b0 -> b0 -> Reader Store Int\n      Where: ‘b0’ is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                  ^\n\napp/Main.hs:43:20: error:\n    • Found hole: _ :: IArith -> b0\n      Where: ‘b0’ is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                    ^\n```\n\nWe can see that we have a free type variable, `b0`. We can also see that the second hole has a shape similar to\nsomething we have: `g :: IArith -> Reader Store Int`. Let's plug in `g` for the second hole (therefore setting\n`b0 ~ Reader Store Int`) and see what that does for us.\n\n```haskell\nfoo :: (Int -> Int -> Int) -> (IArith -> Reader Store Int) -> IArith -> IArith -> Reader Store Int\nfoo f g x y = on _ g x y\n```\n\n```\napp/Main.hs:43:18: error:\n    • Found hole:\n        _ :: Reader Store Int -> Reader Store Int -> Reader Store Int\n    ...\n   |\n43 | foo f g x y = on _ g x y\n   |                  ^\n```\n\nIf you squint, the type of `f` and the type of the hole look kind of similar...\n\n```haskell\n_ :: Reader Store Int -> Reader Store Int -> Reader Store Int\nf ::              Int ->              Int ->              Int\n```\n\nWe have a pure function on `Int`s and we want a similar function on `Ints` where each argument and the result _also_\nhave an associated environment. In Haskell terms, we want to \"lift\" the function we have into the Reader monad. This situation turns out to be incredibly common when dealing with monads. For functions of two arguments, Haskell has a function, `liftM2`, that will do precisely what we want.\n\n```haskell\nliftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r\n```\n\nTherefore, we can write `foo` as follows:\n\n```haskell\nfoo :: (Int -> Int -> Int) -> (IArith -> Reader Store Int) -> IArith -> IArith -> Reader Store Int\nfoo f g x y = on (liftM2 f) g x y\n```\n\nI'm not sure if there's some kind of naming convention for functions like these, but I went with `onLiftM2` because...\nit's `on`... after `liftM2`. Eta-reducing and generalizing the type signature (which will allow the same function to be used for boolean evaluation!), we arrive at the final definition of both `onLiftM2` and `evalArith`.\n\n```haskell\nonLiftM2 :: Monad m => (a -> a -> c) -> (b -> m a) -> b -> b -> m c\nonLiftM2 = on . liftM2\n\nevalArith :: IArith -> Reader Store Int\n...\nevalArith (Plus x y)  = onLiftM2 (+) evalArith x y\nevalArith (Minus x y) = onLiftM2 (-) evalArith x y\nevalArith (Times x y) = onLiftM2 (*) evalArith x y\n```\n\n## Conclusion\n\nAnd that's it! We started with some repetitive code and used the power of type-driven development and monads to...\nincrease the size of the code (measured in number of characters) by about 40%! One might look at that result ask why we bothered doing all of this. While eliminating repetition _can_ (and often does, at larger scales) decrease code size, that's not its primary goal.\n\nEliminating repetition serves primarily to decrease cognitive load. At first, one might disagree with that conclusion. It is clearly easier to write repetitive code. After all, the repetitive solution was the first we came up with, and it worked fine. To understand the final version, you have to understand `on`, `liftM2`, `Reader`, and more! Surely that makes the cognitive load associated with the final version higher!\n\nI would disagree. Decreasing cognitive load is something that is becoming increasingly popular in modern programming (largely inspired by functional programming). It manifests itself as things like static typing or Rust's borrow checker, neither of which are always _easy_ to work with/around. Even so, by their nature, they limit the number of things programmers have to think about. Similarly, recognizing and abstracting patterns allows readers of code to learn something once and then re-use that knowledge where the abstraction is used.\n\nThis specific example _is_ over-engineered, but the same principles apply when working with much larger codebases where the benefits increase exponentially. And, of course, it was really about the friends we made along the way.\n","code":"var Component=(()=>{var d=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var u=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),N=(s,e)=>{for(var a in e)t(s,a,{get:e[a],enumerable:!0})},h=(s,e,a,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!j.call(s,l)&&l!==a&&t(s,l,{get:()=>e[l],enumerable:!(i=p(e,l))||i.enumerable});return s};var f=(s,e,a)=>(a=s!=null?d(y(s)):{},h(e||!s||!s.__esModule?t(a,\"default\",{value:s,enumerable:!0}):a,s)),g=s=>h(t({},\"__esModule\",{value:!0}),s);var c=u((k,r)=>{r.exports=_jsx_runtime});var b={};N(b,{default:()=>I,frontmatter:()=>w});var n=f(c()),w={title:\"Eliminating repetition\",subtitle:\"over-engineering a homework assignment for fun\",date:\"2022-01-28\"};function o(s){let e=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",span:\"span\",a:\"a\",blockquote:\"blockquote\",em:\"em\"},s.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:`For a class assignment, I had to write a tiny interpreter for a toy language whose specification was given to us. This\npost explores the process of recognizing and eliminating some repetition in the interpreter.`}),`\n`,(0,n.jsx)(e.h2,{children:\"Basic factoring\"}),`\n`,(0,n.jsx)(e.p,{children:`The language has basic arithmetic operations like plus, minus, and times which are modeled in the obvious way. An\ninitial attempt at the function for evaluating arithmetic expressions might look something like the\nfollowing.`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-ocaml\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"rec\"}),\" eval_arith (s : store) (a: iarith) -> \",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"int\"}),` =\n  `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"match\"}),\" a \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"with\"}),`\n  ...\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` (x, y) -> eval_arith s x + eval_arith s y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` (x, y) -> eval_arith s x - eval_arith s y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` (x, y) -> eval_arith s x * eval_arith s y\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that the \",(0,n.jsx)(e.code,{children:\"store\"}),` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.`]}),`\n`,(0,n.jsx)(e.p,{children:`Honestly, this code is perfectly fine as-is, but I just can't help myself when I see a pattern like that... We can\nfactor out the repetition by writing something like:`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-ocaml\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),` foo f g a b = f (g a) (g b)\n\n`,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"rec\"}),\" eval_arith (s : store) (a: iarith) -> \",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"int\"}),` =\n  `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"match\"}),\" a \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"with\"}),`\n  ...\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` (x, y) -> foo ( + ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` (x, y) -> foo ( - ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` (x, y) -> foo ( * ) (eval_arith s) x y\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"foo\"}),\" is a function that applies a function to \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),` and then combines the results of those functions using a\ngiven binary operator. It has the type `,(0,n.jsx)(e.code,{children:\"('a -> 'a -> 'b) -> ('c -> 'a) -> 'c -> 'c -> 'b\"}),`. A quick\n`,(0,n.jsx)(e.a,{href:\"https://hoogle.haskell.org/?hoogle=(a%20-%3E%20a%20-%3E%20b)%20-%3E%20(c%20-%3E%20a)%20-%3E%20c%20-%3E%20c%20-%3E%20b\",children:\"hoogle search\"}),`\nshows that Haskell has such a function called `,(0,n.jsx)(e.code,{children:\"on\"}),\" in \",(0,n.jsx)(e.code,{children:\"base\"}),\", so let's call it that.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-ocaml\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),` on f g a b = f (g a) (g b)\n\n`,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"rec\"}),\" eval_arith (s : store) (a: iarith) -> \",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"int\"}),` =\n  `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"match\"}),\" a \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"with\"}),`\n  ...\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` (x, y) -> on ( + ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` (x, y) -> on ( - ) (eval_arith s) x y\n  | `,(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` (x, y) -> on ( * ) (eval_arith s) x y\n`]})}),`\n`,(0,n.jsx)(e.h2,{children:\"The Reader Monad\"}),`\n`,(0,n.jsx)(e.p,{children:`At this point, I'm fairly satisfied with this aspect of the implementation, but I want to revisit another aspect that I\nmentioned earlier:`}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Note that the \",(0,n.jsx)(e.code,{children:\"store\"}),` argument maps variable names to integer values. This is the \"environment\" that evaluation takes place in. Evaluation of plus, minus, and times expressions doesn't immediately need access to variable bindings, so the environment is simply passed through to the evaluations of each sub-expression.`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Classically, we use the \",(0,n.jsx)(e.code,{children:\"Reader\"}),` monad to do this environment passing implicitly. I've only been playing with OCaml\nfor a week or so, but my understanding is that this kind of functional programming is not quite so popular in OCaml (the standard library does not have `,(0,n.jsx)(e.code,{children:\"Reader\"}),\" and I couldn't find a de facto standard implementation like in Haskell's \",(0,n.jsx)(e.code,{children:\"mtl\"}),`).\nGiven that, I decided to quickly re-implement the language in Haskell where I can make use of `,(0,n.jsx)(e.code,{children:\"mtl\"}),\", \",(0,n.jsx)(e.code,{children:\"do\"}),` notation,\netc..`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"Reader\"}),\" to pass around the environment, we can write \",(0,n.jsx)(e.code,{children:\"evalArith\"}),\" as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n...\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),\" x y) = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn <- evalArith x\n  yn <- evalArith y\n  return $ xn + yn\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),\" x y) = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn <- evalArith x\n  yn <- evalArith y\n  return $ xn - yn\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),\" x y) = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn <- evalArith x\n  yn <- evalArith y\n  return $ xn * yn\n`]})}),`\n`,(0,n.jsx)(e.p,{children:`Success! The environment no longer needs to be explicitly passed down to the sub-computations. Again, there's a\nnot-insignificant amount of repetition here. Let's factor it out:`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo'\"}),\" f g x y = \",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"do\"}),`\n  xn <- g x\n  yn <- g y\n  return $ f xn yn\n\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n...\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` x y) = foo (+) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` x y) = foo (-) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` x y) = foo (*) evalArith x y\n`]})}),`\n`,(0,n.jsx)(e.p,{children:\"I'm not exactly sure what to call this function yet, but let's move on for now.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Combining them\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"I'm still not quite satisfied with this implementation. In the first section, we discovered a function, \",(0,n.jsx)(e.code,{children:\"on\"}),`, that\nencapsulates the idea of combining the results of applying a function to two different arguments. Now, we're still doing\nthat, but we're not using `,(0,n.jsx)(e.code,{children:\"on\"}),\"! Let's see how we can define \",(0,n.jsx)(e.code,{children:\"foo\"}),\" in terms of \",(0,n.jsx)(e.code,{children:\"on\"}),\" to get the best of both worlds.\"]}),`\n`,(0,n.jsx)(e.p,{children:`To start, let's lay out the types of each function and try to solve the type puzzle (we'll need to figure out how to\nfit together the \"pieces\").`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"on\"}),`  :: (b   -> b   -> c  ) -> (a      -> b               ) -> a      -> a      -> c\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[`Lining up the types like this shows how these have very similar shapes! However, we quickly realize that there's no\nconsistent instantiation of the type variables. We have `,(0,n.jsx)(e.code,{children:\"a ~ IArith\"}),\", but \",(0,n.jsx)(e.code,{children:\"b\"}),\" needs to be both \",(0,n.jsx)(e.code,{children:\"Int\"}),` and\n`,(0,n.jsx)(e.code,{children:\"Reader Store Int\"}),\" (and similarly for \",(0,n.jsx)(e.code,{children:\"c\"}),\"). This tells us that \",(0,n.jsx)(e.code,{children:\"foo\"}),\" and \",(0,n.jsx)(e.code,{children:\"on\"}),\" aren't the same, so we need \",(0,n.jsx)(e.em,{children:\"something\"}),` to\ntransform one to the other. To determine what that \"something\" is, let's consider what we have and what we need. We'll\nuse typed holes to guide the process.`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on _ _ _ _\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We already know that \",(0,n.jsx)(e.code,{children:\"a ~ IArith\"}),\" is valid, and we have two arguments of that type, \",(0,n.jsx)(e.code,{children:\"x\"}),\" and \",(0,n.jsx)(e.code,{children:\"y\"}),\", so let's plug those in.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on _ _ x y\n`]})}),`\n`,(0,n.jsx)(e.p,{children:\"Let's take a look at what the compiler has to say about the remaining holes.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`app/Main.hs:43:18: error:\n    \\u2022 Found hole: _ :: b0 -> b0 -> Reader Store Int\n      Where: \\u2018b0\\u2019 is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                  ^\n\napp/Main.hs:43:20: error:\n    \\u2022 Found hole: _ :: IArith -> b0\n      Where: \\u2018b0\\u2019 is an ambiguous type variable\n    ...\n   |\n43 | foo f g x y = on _ _ x y\n   |                    ^\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can see that we have a free type variable, \",(0,n.jsx)(e.code,{children:\"b0\"}),`. We can also see that the second hole has a shape similar to\nsomething we have: `,(0,n.jsx)(e.code,{children:\"g :: IArith -> Reader Store Int\"}),\". Let's plug in \",(0,n.jsx)(e.code,{children:\"g\"}),` for the second hole (therefore setting\n`,(0,n.jsx)(e.code,{children:\"b0 ~ Reader Store Int\"}),\") and see what that does for us.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on _ g x y\n`]})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`app/Main.hs:43:18: error:\n    \\u2022 Found hole:\n        _ :: Reader Store Int -> Reader Store Int -> Reader Store Int\n    ...\n   |\n43 | foo f g x y = on _ g x y\n   |                  ^\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you squint, the type of \",(0,n.jsx)(e.code,{children:\"f\"}),\" and the type of the hole look kind of similar...\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"_\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"f\"}),\" ::              \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" ->              \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" ->              \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We have a pure function on \",(0,n.jsx)(e.code,{children:\"Int\"}),\"s and we want a similar function on \",(0,n.jsx)(e.code,{children:\"Ints\"}),\" where each argument and the result \",(0,n.jsx)(e.em,{children:\"also\"}),`\nhave an associated environment. In Haskell terms, we want to \"lift\" the function we have into the Reader monad. This situation turns out to be incredibly common when dealing with monads. For functions of two arguments, Haskell has a function, `,(0,n.jsx)(e.code,{children:\"liftM2\"}),\", that will do precisely what we want.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"liftM2\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Monad\"}),` m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Therefore, we can write \",(0,n.jsx)(e.code,{children:\"foo\"}),\" as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),\" :: (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),\") -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"foo\"}),` f g x y = on (liftM2 f) g x y\n`]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"I'm not sure if there's some kind of naming convention for functions like these, but I went with \",(0,n.jsx)(e.code,{children:\"onLiftM2\"}),` because...\nit's `,(0,n.jsx)(e.code,{children:\"on\"}),\"... after \",(0,n.jsx)(e.code,{children:\"liftM2\"}),\". Eta-reducing and generalizing the type signature (which will allow the same function to be used for boolean evaluation!), we arrive at the final definition of both \",(0,n.jsx)(e.code,{children:\"onLiftM2\"}),\" and \",(0,n.jsx)(e.code,{children:\"evalArith\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-haskell\",children:[(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"onLiftM2\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Monad\"}),` m => (a -> a -> c) -> (b -> m a) -> b -> b -> m c\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"onLiftM2\"}),` = on . liftM2\n\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" :: \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"IArith\"}),\" -> \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Reader\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Store\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Int\"}),`\n...\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Plus\"}),` x y)  = onLiftM2 (+) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Minus\"}),` x y) = onLiftM2 (-) evalArith x y\n`,(0,n.jsx)(e.span,{className:\"hljs-title\",children:\"evalArith\"}),\" (\",(0,n.jsx)(e.span,{className:\"hljs-type\",children:\"Times\"}),` x y) = onLiftM2 (*) evalArith x y\n`]})}),`\n`,(0,n.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,n.jsxs)(e.p,{children:[`And that's it! We started with some repetitive code and used the power of type-driven development and monads to...\nincrease the size of the code (measured in number of characters) by about 40%! One might look at that result ask why we bothered doing all of this. While eliminating repetition `,(0,n.jsx)(e.em,{children:\"can\"}),\" (and often does, at larger scales) decrease code size, that's not its primary goal.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Eliminating repetition serves primarily to decrease cognitive load. At first, one might disagree with that conclusion. It is clearly easier to write repetitive code. After all, the repetitive solution was the first we came up with, and it worked fine. To understand the final version, you have to understand \",(0,n.jsx)(e.code,{children:\"on\"}),\", \",(0,n.jsx)(e.code,{children:\"liftM2\"}),\", \",(0,n.jsx)(e.code,{children:\"Reader\"}),\", and more! Surely that makes the cognitive load associated with the final version higher!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"I would disagree. Decreasing cognitive load is something that is becoming increasingly popular in modern programming (largely inspired by functional programming). It manifests itself as things like static typing or Rust's borrow checker, neither of which are always \",(0,n.jsx)(e.em,{children:\"easy\"}),\" to work with/around. Even so, by their nature, they limit the number of things programmers have to think about. Similarly, recognizing and abstracting patterns allows readers of code to learn something once and then re-use that knowledge where the abstraction is used.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This specific example \",(0,n.jsx)(e.em,{children:\"is\"}),\" over-engineered, but the same principles apply when working with much larger codebases where the benefits increase exponentially. And, of course, it was really about the friends we made along the way.\"]})]})}function v(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,Object.assign({},s,{children:(0,n.jsx)(o,s)})):o(s)}var I=v;return g(b);})();\n;return Component;"},"_id":"eliminating-repetition.mdx","_raw":{"sourceFilePath":"eliminating-repetition.mdx","sourceFileName":"eliminating-repetition.mdx","sourceFileDir":".","contentType":"mdx","flattenedPath":"eliminating-repetition"},"type":"Post","slug":"eliminating-repetition"}},"__N_SSG":true}